{"name":"Rop","tagline":"A lightweight command line option parser written in Java","body":"# Rop\r\n\r\n[![Build Status](https://travis-ci.org/ryenus/rop.png?branch=master)](https://travis-ci.org/ryenus/rop)\r\n\r\nA lightweight command line option parser written in Java.\r\n\r\n\r\n## Introduction\r\n\r\nRop is designed to be minimal meanwhile convenient, and to cover most usual command line parsing use cases listed below:\r\n\r\n| Command Line App Examples | Classification / Description\r\n|---------------------------|---------------------------------------------\r\n| `mv` and `ls`             | simple commands that just do one thing\r\n| `git add`, `git commit`   | sub-commands, but single invocation\r\n| `mvn clean test`          | sub-commands supporting multiple invocations\r\n\r\nAll these types of command line applications can be built using Rop.\r\n\r\nMore than that, Rop endorses building command line option parsers the Java way. Instead of following the traditional [GetOpt](http://en.wikipedia.org/wiki/Getopt) way of building an option parser, Rop follows an approache that is:\r\n\r\n* Annotation based, and\r\n* Object oriented\r\n\r\nYou can build an option parser by defining Command classes and their fields annotated with the corresponding Option switches.\r\n\r\nAlso, each Command can optionally have a `run()` method to define its behavior, which would be called automatically after parsing.\r\n\r\n\r\n## Getting Started\r\n\r\nRop is available as a Maven artifact `com.github.ryenus:rop`. Simply add this to the dependencies section in your pom.xml:\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>com.github.ryenus</groupId>\r\n  <artifactId>rop</artifactId>\r\n  <version>${rop.version}</version>\r\n</dependency>\r\n```\r\n\r\nYou can always get the latest source code from https://github.com/ryenus/rop.\r\n\r\n\r\n### Usage example\r\n\r\nHere's a quick example to demonstrate how to use Rop:\r\n\r\n```java\r\nimport com.github.ryenus.rop.OptionParser;\r\nimport com.github.ryenus.rop.OptionParser.Command;\r\nimport com.github.ryenus.rop.OptionParser.Option;\r\n\r\n\r\n// 1. Here we define the Command class\r\n@Command(name = \"foo\", descriptions = \"A simple command with a few options.\")\r\npublic class FooCommand {\r\n\r\n\t@Option(opt = { \"-V\", \"--verbose\" }, description = \"explain what is being done\")\r\n\tboolean verbose;\r\n\r\n\t@Option(opt = { \"-n\", \"--number\" }, description = \"certain number\")\r\n\tint n = 3; // default to 3\r\n\r\n\tvoid run(OptionParser parser, String[] params) { // either or both args can be omitted\r\n\t\tif (verbose) { // 'verbose' is set to true by the parser\r\n\t\t\tSystem.out.println(\"opt arg: \" + n); // => 4\r\n\t\t\tfor (String param : params) {\r\n\t\t\t\tSystem.out.println(\"param: \" + param); // a, b\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void main(String[] args) { // assume this is called with 'java TheMain --verbose -n 4 a b'\r\n\t\t// 2. Create the OptionParser instance along with the Command class\r\n\t\tOptionParser parser = new OptionParser(FooCommand.class);\r\n\r\n\t\t// 3. Parse the args\r\n\t\tparser.parse(args);\r\n\r\n\t\t// Here FooCommand.run() would be called automatically, so you don't have to\r\n\t}\r\n}\r\n\r\n```\r\n\r\nIn this example, we've basically done 3 things:\r\n\r\n1. define the Command class, with @Command, and @Option annotations\r\n2. instantiate the OptionParser class along with the Command class\r\n3. parse the command line args with OptionParser.parse()\r\n\r\nThis is common to all comand line applications built using Rop, regardless how complex the application is.\r\n\r\nFor API details, please refer to the javadoc.\r\n\r\n\r\n## Understanding Rop\r\n\r\nThe most significant thing in Rop is the `OptionParser` class, with which Commands are registered, then you call its `parse()` method to parse the command line arguments.\r\n\r\n\r\n### The `@Command` Annotation\r\n\r\nAny vanilla class can be turned to a valid Command with the `@Command` annotation, regardless it has Options or not.\r\n\r\nHence we call it a *Command class* here.\r\n\r\n\r\n### The `@Option` Annotation\r\n\r\nIn a Command class, those fields having the `@Option` annotation, are viable to be set from command line argments during parsing. The above example should make this pretty clear.\r\n\r\n\r\n### Command Registration\r\n\r\nThe `OptionParser` class provides a `register()` method to allow a Command, i.e. a class annotated with `@Command`, or its instance, to be registered with the parser. The `register()` method is chainable, as it always returns the parser object.\r\n\r\nA Command can also be registered by passing it directly to the constructor `OptionParser()`, so you don't have to explicitly call the `register()` method. Also, the constructor can be called with any number of Commands.\r\n\r\n\r\n### Post Parsing Hook - Method `Command.run()`\r\n\r\nA Command can have a little magic. If it has a `run()` method, the parser would call this method at the end of parsing if the Command appeared in the command line.\r\n\r\nIn the above example, `FooCommand.run()` would be called automatically, it would receive a reference to the parser itself, and an array which consists of all the remaining arguments.\r\n\r\nIf you're not interested in getting either the parser or the parameters, just omit any of them, or both.\r\n\r\nNote that if there're more than one `run()` methods in a Command class, only the first would be called.\r\n\r\n\r\n### Using Sub-commands\r\n\r\nTypical commands, such as [`mv`](http://en.wikipedia.org/wiki/Mv) and [`ls`](http://en.wikipedia.org/wiki/Ls) in Unix, are quite simple, they're designed to [do one thing and do it well](http://en.wikipedia.org/wiki/Unix_philosophy). It needs just one Command class to build such a simple command line application. However, not everything is simple like this.\r\n\r\nOften, your command line application needs to do more than one thing, naturally you'll need more than one Command classes.\r\n\r\n\r\n#### The Parent Command\r\n\r\nPlease note that besides all the sub-commands, as with `git add`, and `git commit`, you need a *main* Command class as the parent.\r\n\r\nThe parent Command usually becomes a no-action Command, it's often used to handle global options, especially `--version`, and `--help`.\r\n\r\n\r\n#### Allowing only One Sub-command Being Called\r\n\r\nCertain command line applications, for example, [Git](http://git-scm.com/) provides a bunch of sub-commands to do many different things, such as `git add`, `git commit` and `git log`.\r\n\r\nBy default, Rop only allows one sub-command to be called on the command line, which is the case with Git.\r\n\r\nThis is done by calling the 1-arg version of `OptionParser#parse()`, i.e.:\r\n\r\n```java\r\nparser.parse(args);\r\n```\r\n\r\nThough Git provides many sub-commands, as with the default parsing behavior, you can only use one sub-command at a time, for example, in `git add ... commit ...`, the argument 'commit' loses its magic and would be treated as something to be added with `git add`, not the sub-command `git commit`.\r\n\r\n#### Allowing Multiple Sub-commands to Be Called Together\r\n\r\nBut for [Ant](http://ant.apache.org/) and [Maven](http://maven.apache.org/), it's a different story. As in `mvn clean test`, you can run multiple sub-commands together. Can we do that as well? Sure, it's actually very simple:\r\n\r\nRather than calling\r\n\r\n```java\r\nparser.parse(args);\r\n```\r\n\r\ninstead, call\r\n\r\n```java\r\nparser.parse(args, true);\r\n```\r\n\r\nThe extra boolean argument, when set to 'true', tells the parser to recognize all the sub-commands it detected. For each properly recognized sub-command, its `run()` method, if exists, would be called, in the order they appeared on the command line.\r\n\r\n### Managed Instance Objects of Command Classes\r\n\r\nInternally Rop helps manage all the instance objects of registered Command classes, which makes it possible to get the instance object of any registered Command class, e.g.:\r\n\r\n```java\r\nparser = new OptionParser(FooCommand.class); // register with class FooCommand\r\n\r\nparser.get(FooCommand.class); // this is how to get the instance object for FooCommand class\r\n```\r\n\r\nA typical usage of this is in your `Command#run()` method:\r\n\r\n```java\r\nrun(OptionParser parser, String[] params) {\r\n  FooCommand foo = parser.get(FooCommand.class);\r\n  System.out.println(foo.bar);\r\n}\r\n```\r\n\r\nThis allows your Commands to be loosely decoupled and flexibly reused.\r\n\r\n\r\n### Supported Field Types and Default Values\r\n\r\n* String, and all primitive type and their wrapper types are directly supported.\r\n* File, Path are supported as well, but not Date/Time yet.\r\n* There might be a customizable type binder available in the future.\r\n\r\nAs in the above example, a default option value can be directly set to its associated field. If not set, the option values default to their type default, as list above, according to Java Tutorial - [Primitive Data Types](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html).\r\n\r\n<pre>\r\nTypes                   Default Values\r\nboolean                 false\r\nbyte                    0\r\nshort                   0\r\nint                     0\r\nlong                    0L\r\nfloat                   0.0f\r\ndouble                  0.0d\r\nchar                    '\\u0000'\r\nString/Wrapper/Object   null\r\n</pre>\r\n\r\n### Built-in Help\r\n\r\nIf option '--help' is present, the parser will:\r\n\r\n1. display help information constructed from the Commands/Options annotations\r\n2. call System.exit(0)\r\n\r\n### Error Handling\r\n\r\nAny possible error would be thrown as a RuntimeException, or its subclass, provided with proper error massege. You might want to catch the exception, print the error message and/or the help information before exiting the program. This task is intentionally left to you so that you can control how your program behaves upon parsing errors before terminating.\r\n\r\n## Contributing\r\n\r\nIf you'd like to help improve Rop, clone the project with Git by running:\r\n\r\n    $ git clone https://github.com/ryenus/rop\r\n\r\nWork your magic and then submit a pull request. We love pull requests!\r\n\r\nIf you don't have the time to work on Rop, but found something we should know about, please submit an issue.\r\n\r\n## License\r\n\r\nRop is released under the [MIT License](http://www.opensource.org/licenses/MIT).\r\n\r\n## Related projects\r\n\r\n* [java-getopt](https://github.com/arenn/java-getopt)\r\n* [JOpt Simple](http://pholser.github.com/jopt-simple)\r\n* [JCommander](https://github.com/cbeust/jcommander)\r\n* [Commons CLI](http://commons.apache.org/proper/commons-cli/)\r\n* [joptparse](https://code.google.com/p/joptparse)\r\n","google":"UA-39711562-1","note":"Don't delete this file! It's used internally to help with page regeneration."}